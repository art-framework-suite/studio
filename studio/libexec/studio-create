#!/usr/bin/env bash

# Usage: studio create <MANDATORY> [-e] (collab code) 
#	       	       <OPTIONAL>  [-v] (version) <OPTIONAL >[-q] (qualifier) 
# Summary: Creates the study area!
# This will make your directory tree and populate appropriate cmake files!
# Help: studio create will make your study area. studio create requires a ups installed product.
# this can be anything from art to lariatsoft. If additional qualifiers are not passed default 
# versions are chosen by studio 
#     -e	preceeds the name of an installed ups product. These options can be passed in any order 
#		but this one is mandatory.
#
#     -v 	preceeds the version number. If you ask a version number that is not available from ups active
#		then ups will yell at you.
#     
#     -q	preceeds the qualifer. Same.

#     ex.	studio create -e lariatsoft -v v06_03_00 -q e10:prof
#     or	studio create -e duneTPC -q e10:debug 
#     or	studio create -e uboonecode
set -e
#=========================================================================================================
#========================================================================================================= 
#=========================================READING IN ARGUMENTS============================================
#=========================================================================================================
#=========================================================================================================


echo "Welcome to studio!"
echo ""
#checking for empty call
if [ -z "$1" ]; then
echo "Please pass arguments..."
exit 2
fi

#assigning arguments
#first option
if [ "$1" == "-e" ]; then
    exp=$2
fi
if [ "$1" == "-v" ]; then
    ver=$2
fi
if [ "$1" == "-q" ]; then
    qual=$2
fi
if [ "$1" == "-r" ]; then
    rep=$2
fi
##second option
if [ "$3" == "-e" ]; then
    exp=$4
fi
if [ "$3" == "-v" ]; then
    ver=$4
fi
if [ "$3" == "-q" ]; then
    qual=$4
fi
if [ "$3" == "-r" ]; then
    rep=$4
fi

##third option
if [ "$5" == "-e" ]; then
    exp=$6
fi
if [ "$5" == "-v" ]; then
    ver=$6
fi
if [ "$5" == "-q" ]; then
    qual=$6
fi
if [ "$5" == "-r" ]; then
    rep=$6
#else
#    echo "Options not recognized... please see help pages."
fi

#empty qual messages
if [ -z "$ver" ] && [ -z "$rep" ]; then
echo "You have not supplied a version number for your collaboration's code."
echo "Default version used."
echo "Check the help pages to see which is the default version."
echo ""	
fi

if [ -z "$qual" ] && [ -z "$rep" ]; then
echo "You have not supplied a qualifier for the version number you specified of your collaboration's code."
echo "Default qualifiers used."
echo "Check the help pages to see which are the default qualifiers."
echo ""
fi


#=========================================================================================================
#==============================================MAKING===================================================== 
#=============================================NEC DIRS====================================================
#===========================================&cmakelists?==================================================
#====================================================================+====================================


#big if check for art workbook

#art workbook garbage
if [ "$rep" == "art-workbook" ]; then
echo "hmm... you want the art workbook.."
echo "here we go..."
git clone http://cdcvs.fnal.gov/projects/art-workbook 
mv $PWD/art-workbook $PWD/study-area
mv $PWD/study-area/art-workbook $PWD/study-area/src
cd study-area
mkdir build
touch build/CMakeCache.txt
mkdir ext
BUILD_DIR=`pwd`/build	
EXT_PATH=`pwd`/ext
SRC_DIR=`pwd`/src
#LIB_PATH=${INSTALL_PATH}/lib
#INC_PATH=${INSTALL_PATH}/include
#BIN_PATH=${INSTALL_PATH}/bin
#
#if [ -z "$LD_LIBRARY_PATH" ]
#then
# export LD_LIBRARY_PATH=$LIB_PATH
#else
# export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:$LIB_PATH
#fi
#PATH=${PATH}:${BIN_PATH}
cat <<-EOF > setup.sh
#!/usr/bin/env bash
#Setup script for "$exp" with requested version and qualifiers (may default to current version) 
source ups/setup_for_development -d e7:s14
export BUILD_PATH="$BUILD_DIR"
export SRC_PATH="$SRC_DIR"
LD_LIBRARY_PATH=$BUILD_DIR/lib:\$LD_LIBRARY_PATH
	EOF
#temp fix for studio not being an installed prod?
echo "$PWD"
cp ../studio* .

echo "study area created. source setup script (every time you log in) and you're good to go. check help pages for more"
else

#NORMAL DIRECTORY TREE
mkdir study-area
cd study-area
cp ../studio* .
    echo -e "\nChecking for a build directory..."	
	if [ -d build ]; then 
	    echo "build directory already exists"
	    echo ""
	else
	    mkdir build
	    touch build/CMakeCache.txt
	    echo "made build directory\n"
            echo ""
	fi
	
    echo -e "Checking for an external  directory..."	
	if [ -d ext ]; then
	    echo "ext directory already exists\n"
            echo ""
	else
	    mkdir ext 
	    echo "made ext directory\n"
	    echo ""
	fi
	
    echo -e "Checking for a source  directory..."	
	if [ -d src ]; then
	    echo "source directory already exists\n"
            echo ""
	else
	    mkdir src
	    echo "made src directory\n"
	    echo ""
	fi
echo "study area created. source setup script (every time you log in) and you're good to go. check help pages for more"

# === may need to change where this is done ===
# === probably after the if switch for wkbk ===	
	BUILD_DIR=`pwd`/build	
	EXT_PATH=`pwd`/ext
        SRC_DIR=`pwd`/src
	#LIB_PATH=${INSTALL_PATH}/lib
	##INC_PATH=${INSTALL_PATH}/include
	#BIN_PATH=${INSTALL_PATH}/bin
	##
	#if [ -z "$LD_LIBRARY_PATH" ]
	#then
	# export LD_LIBRARY_PATH=$LIB_PATH
	#else
	# export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:$LIB_PATH
	#fi
	##
	#PATH=${PATH}:${BIN_PATH}
	##



#=========================================================================================================
#==============================================MAKING===================================================== 
#===========================================SETUP SCRIPT==================================================
#=========================================================================================================
#=========================================================================================================

# ----------------------------------------------
# --- writing "default" variables to version ---
# --- and qual. otherwise keep as is. How do I -
# --- check for errors? UPS will complain but --
# --- can I do better? maybe check against ups -
# --- but for now this works                 ---
# ----------------------------------------------

#no version specified but qual specified
if [ -z "$ver" ] && [ ! -z "$qual" ]; then
  ver="$(ups list -aK+ "$exp" | sort | tail -1 | cut -d ' ' -f 2 | cut -d '"' -f 2)"
  echo "no version specified but qual specified..."
  echo "setup $exp $ver -q $qual"
  echo ""
fi
#no qual specified but version specified
if [ -z "$qual" ] && [ ! -z "$ver" ]; then
  e="$(ups list -aK+ "$exp" | sort | tail -1 | cut -d ' ' -f 4 | cut -d '"' -f 2 | cut -d ":" -f 1)"
  b="$(ups list -aK+ "$exp" | sort | tail -1 | cut -d ' ' -f 4 | cut -d '"' -f 2 | cut -d ":" -f 2)"
  qual="${e}:${b}"
  echo "no qual specified but ver specified..."
  echo "setup $exp $ver -q $qual"
  echo ""
fi
#no version and no qual specified? 
if [ -z "$ver" ] && [ -z "$qual"]; then
  ver="$(ups list -aK+ "$exp" | sort | tail -1 | cut -d ' ' -f 2 | cut -d '"' -f 2)"
  e="$(ups list -aK+ "$exp" | sort | tail -1 | cut -d ' ' -f 4 | cut -d '"' -f 2 | cut -d ":" -f 1)"
  b="$(ups list -aK+ "$exp" | sort | tail -1 | cut -d ' ' -f 4 | cut -d '"' -f 2 | cut -d ":" -f 2)"
  qual="${e}:${b}"
  echo "no qual specified and no ver specified..."
  echo "setup $exp $ver -q $qual"
  echo ""
fi

# writing the setup script

cat <<-EOF > setup.sh
#!/usr/bin/env bash
#Setup script for "$exp" with requested version and qualifiers (may default to current version) 
setup $exp $ver -q $qual
export BUILD_PATH=$BUILD_DIR
export SRC_PATH=$SRC_DIR
LD_LIBRARY_PATH=$BUILD_DIR/lib:\$LD_LIBRARY_PATH
	EOF

# <<<<<<<<<<<<<<< ending the check for artworkbook
fi
# >>>>>>>>>>>>>>> ending the check for artworkbook


#=========================================================================================================
#==============================================CMAKE====================================================== 
#=============================================LISTS &=====================================================
#=============================================COMMANDS====================================================
#=========================================================================================================

#CMake stuff
cat <<-'EOF' > helpers.cmake
#cmake macro

#macro for grabbing compiler directories
macro(get_comp_paths)
execute_process(COMMAND type -p g++ OUTPUT_VARIABLE gpp_path)
execute_process(COMMAND type -p gcc OUTPUT_VARIABLE gcc_path) 
message(STATUS "gpp path: ${gpp_path}")
message(STATUS "gcc path: ${gcc_path}")
endmacro(get_comp_paths)


#some jank map macro
macro(insert_into_map _key _val)
  set("map_${_key}" "${_val}")
endmacro(insert_into_map)


#here is where we find the include directories
macro(find_inc_dirs)

#getting ups product names
execute_process(COMMAND ups active COMMAND grep -v "Active ups products:" COMMAND cut -d " " -f 1 COMMAND tr '[a-z]' '[A-Z]' OUTPUT_VARIABLE dirs)
#trimming the end
string(LENGTH ${dirs} string_length)
string(SUBSTRING ${dirs} 0 ${string_length}-2 dirs_trimmed)
#making the string of dir names into a list
string(REPLACE "\n" ";" dirs_list ${dirs_trimmed})
#THIS IS THE VARIABLE WE WILL WANT TO USE IN CMakeList
set(inc_dirs_list)
#looping over product list to grab inc dirs
foreach(prod ${dirs_list})
if(prod STREQUAL "")
continue()
endif(prod STREQUAL "")
list(APPEND inc_dirs_list $ENV{${prod}_INC})
endforeach(prod)
#message(STATUS "${inc_dirs_list}")

endmacro()


#========================
#========================
#========================


#here is where we find the lib directories 
macro(find_lib_dirs)

execute_process(COMMAND ups active COMMAND grep -v "Active ups products:" COMMAND cut -d " " -f 1 COMMAND tr '[a-z]' '[A-Z]' OUTPUT_VARIABLE dirs)
string(LENGTH ${dirs} string_length)
string(SUBSTRING ${dirs} 0 ${string_length}-2 dirs_trimmed)
string(REPLACE "\n" ";" dirs_list ${dirs_trimmed})


set(lib_dirs_list)
set(lib_prod_list)
foreach(prod ${dirs_list})
#message(STATUS "test ${prod}")
#message(STATUS "var $ENV{${prod}_LIB}")
if(prod STREQUAL "")
continue()
endif(prod STREQUAL "")
if(IS_DIRECTORY $ENV{${prod}_LIB})
#message(STATUS "$ENV{${prod}_LIB}")
list(APPEND lib_prod_list ${prod})
list(APPEND lib_dirs_list $ENV{${prod}_LIB})
insert_into_map(${prod} $ENV{${prod}_LIB})
endif(IS_DIRECTORY $ENV{${prod}_LIB})
endforeach(prod)
#message(STATUS "${lib_dirs_list}")

endmacro()
	EOF

cat <<-'EOF' > CMakeLists.txt 
#CMakeLists for "$exp" with specific directory tree
include(helpers.cmake)
cmake_minimum_required(VERSION 2.8.9)
project(study_area)
set(CMAKE_CXX_FLAGS "-std=c++14")
set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,--no-undefined")
#message(STATUS "build path: $ENV{BUILD_PATH}")
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "$ENV{BUILD_PATH}/lib")

#reading in cmake cache variables from build script
set(in_src ${IS_IN_SRC})
set(work_dir ${WORKING_DIR})
set(build_dir_list ${BUILD_DIRS})

#include directories
find_inc_dirs()
foreach(inc_dir ${inc_dirs_list})
include_directories(${inc_dir})
endforeach(inc_dir ${inc_dirs_list})

#using these jank maps to link libs
find_lib_dirs()
foreach(lib_prod ${lib_prod_list})
    #message(STATUS "new product")
    #message(STATUS "${lib_prod}")
    #message(STATUS "${map_${lib_prod}}")
    file(GLOB so_list ${map_${lib_prod}}/*.so)
    #message(STATUS "${so_list}")
    foreach(so ${so_list})
        #message(STATUS "${so}")
        string(REGEX REPLACE "^.*/lib([^/]*)\\.so$" "\\1" var ${so})
        #message(STATUS ${var})
	set(${var} ${so})
    endforeach(so ${so_list})
endforeach(lib_prod ${lib_prod_list})
    #root special case!
    #message(STATUS "$ENV{ROOTSYS}")
    file(GLOB root_lib_list $ENV{ROOTSYS}/lib/*.so)
    foreach(root_so ${root_lib_list})
        #message(STATUS "${root_so}")
        string(REGEX REPLACE "^/.*lib(.*)\\.so$" "\\1" root_var ${root_so})
        #message(STATUS ${root_var})
	set(${root_var} ${root_so})
    endforeach(root_so ${root_lib_list})

#lib lists per plugin
set(service_lib_list)
set(module_lib_list)
set(source_lib_list)

list(INSERT service_lib_list 0
      ${art_Framework_Services_Registry}
      ${art_Persistency_Common}
      ${art_Utilities}
      ${canvas_Persistency_Common}
      ${canvas_Utilities}
      ${fhiclcpp}
      ${cetlib}
      ${boost_filesystem}
      ${boost_system}
      )
list(INSERT module_lib_list 0
      ${art_Framework_Core}
      ${art_Framework_Principal}
      ${art_Persistency_Common}
      ${art_Persistency_Provenance}
      ${art_Utilities}
      ${canvas_Persistency_Common}
      ${canvas_Persistency_Provenance}
      ${canvas_Utilities}
      ${fhiclcpp}
      ${cetlib}
      ${Core}
      ${boost_filesystem}
      ${boost_system}
      )
list(INSERT source_lib_list 0
      ${art_Framework_IO_Sources}
      ${Boost_FILESYSTEM_LIBRARY}
      ${Boost_SYSTEM_LIBRARY}
      ${art_Framework_Core}
      ${art_Framework_Principal}
      ${art_Persistency_Common}
      ${art_Persistency_Provenance}
      ${art_Utilities}
      ${canvas_Persistency_Common}
      ${canvas_Persistency_Provenance}
      ${canvas_Utilities}
      ${fhiclcpp}
      ${cetlib}
      ${Core}
      ${boost_filesystem}
      ${boost_system}
      )


#adding sources

#if passed an arg
if( NOT build_dir_list STREQUAL "no args")
    message(STATUS "specified dirs are: ${build_dir_list}")
    #add each build dir
    foreach(build_dir ${build_dir_list})
        add_subdirectory(src/${build_dir})
    endforeach(build_dir ${build_dir_list})
#if no args passed
elseif( build_dir_list STREQUAL "no args")
message(STATUS "no specified dirs...")
    #if outside srcs
    if(NOT in_src)
        message(STATUS "not in src dir... building everything...")
        add_subdirectory(src)
        #if in sources
    elseif(in_src)
        message(STATUS "somewhere in src... building current dir...")
        add_subdirectory(${work_dir})
    endif(NOT in_src)
endif( NOT build_dir_list STREQUAL "no args")

#add_executable(Test src/test.cc)
#target_link_libraries(Test fhiclcpp)
	EOF

cat <<-'EOF' > src/CMakeLists.txt
#source cmake list file
#there are two general options:
#    1. everything lives in src directory and we do it all here 
#    2. subdirs (requires user to create some of the structure)
#pro-con is easyness vs. choice of what to build

#here is a basic example for option 1.
#    Plugin_name
#    add_library(<fill in which library>)
#    target_link_library(<more nonsense>)
	EOF
    
