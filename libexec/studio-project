#!/usr/bin/env bash

# Usage: studio project [-e,-s] <product> [-v] <version> [-q <qualifiers>] [-n <dirname> ]
# Summary: Creates a project area for software suite <product>.

# Help: This will create a directory, by default named 'project',
# in the current directory, and in it a small directory tree for your
# work. See 'DIRECTORY STRUCTURE' for complete details on the
# directory structure that is generated.
#
# The project command requires use of a UPS installed product to
# provide the headers your code will include, the libraries to which
# your new code will be linked, and the art framework modules and
# servicesyour FHiCL configuration files will use. Typically this will
# be the code distribution from an experiment, but it could be any UPS
# product.
#
# If no version is specified, the project command will attempt to
# identify and use the most recent version of the named
# product. Specifying a qualifier without explicitly specifying a
# version is unreliable and should be avoided.
#
# If no qualifier is specified, the project command will attempt to use
# whatever qualifiers are found for the selected version of the
# product. If multiple qualifiers are available for that version,
# project command attempts a reasonable choice. In this condition, 
# it is best to specify qualifiers on the command line.
#
# If -n <dirname> is specified, the project directory will be given
# the specified name, rather than the default 'project'.
#
# DIRECTORY STRUCTURE
# The generated directory structure is:
#
# ├── build
# │   └── CMakeCache.txt
# ├── CMakeLists.txt
# ├── ext
# ├── helpers.cmake
# ├── setup.sh
# └── src
#     └── CMakeLists.txt
#
# The 'build' directory is where compiler and linker output will be
# put. The CMakeCache.txt file in this directory is generated and
# updated by CMake, and should not be edited.
#
# The (top-level) CMakeLists.txt contains a great deal of boilerplate
# needed by the CMake build system. It should not require any
# modification. Only edit it if you are a CMake expert, and even in
# that case be careful that your changes are only additions.
#
# The 'ext' directory is a place for you to build any external
# libraries your code will need. If you want to try linking to some
# utility that is built with a standard 'configure/make' system, use
# the --prefix option in configure to point the installation to this
# directory.
#
# The 'helpers.cmake' file contains some CMake macros used by the
# system. If you are a CMake expert, you could add your own macros
# here. Removing or altering the existing macros is likely to break
# the build system.
#
# The 'src' directory is where the source code you write will go. Code
# generated by the module skeleton generators will go here
# automatically.
#
# 'setup.sh' is a bash script must be 'sourced' in each new shell
# session in which you want to work on your project.
# 
# EXAMPLES
#    studio project lariatsoft v06_03_00 -q e10:prof
#    studio project lariatsoft v06_03_00 -q e10:prof -n lariatsoft_project
#    studio project dunetpc v06_18_01
#    studio project dunetpc v06_18_01 -n duntpc_project
#    studio project uboonecode
#    studio project uboonecode -n uboone_project
#
set -e
#=========================================READING IN ARGUMENTS============================================


arrange_opts() {
    local flags args optstr=$1
    shift

    while (($#)); do
        case $1 in
            --) args+=("$@")
                break;
                ;;
            -*) flags+=("$1")
                if [[ $optstr == *"${1: -1}:"* ]]; then
                    flags+=("$2")
                    shift
                fi
                ;;
            * ) args+=("$1")
                ;;
        esac
        shift
    done
    OPTARR=("${flags[@]}" "${args[@]}")
}

#default values
name=project
unset exp
unset qual
unset rep

#assigning arguments
OPTIND=
OPTARR=
optstring=s:v:q:r:n:

arrange_opts "$optstring" "$@"
set -- "${OPTARR[@]}"

OPTIND=1
while getopts $optstring opt;do
    case ${opt} in 
           s|e) 
                exp="$OPTARG"
                ;;
           v) 
                ver="$OPTARG"
                ;;
           q) 
                qual="$OPTARG"
                ;;
           r)
                rep="$OPTARG"
                ;;
           n)
                name="$OPTARG"
                ;;
     esac 
done

shift $((OPTIND-1))

#checking for empty call ans positional arguments
if [ $# == 0 ] ; then
    echo "'studio project' requires specification of a software suite."
    echo "Please try 'studio help project'"
    exit 2
else
    exp=$1;
    shift;
    if [ $# != 0 ] ; then 
        ver=$1
        shift
        echo $@
    fi
fi


# dummy catchers
if [ -z "$exp" ] && [ -z "$rep" ]; then
    echo "Please specify a software suite name."
    exit
fi

if [ ! -z "$exp" ] && [ ! -z "$rep" ]; then
    echo "You cannot specify a software suite name *and* a repository."
    exit
fi


#=========================================================================================================
#==============================================MAKING=====================================================
#=============================================NEC DIRS====================================================
#===========================================&cmakelists?==================================================
#====================================================================+====================================


#big if check for art workbook

#art workbook garbage
if [ "$rep" == "art-workbook" ]; then
    git clone http://cdcvs.fnal.gov/projects/art-workbook
    mv $PWD/art-workbook $PWD/$name
    mv $PWD/$name/art-workbook $PWD/$name/src
    cd $name
    mkdir build
    touch build/CMakeCache.txt
    mkdir ext
    BUILD_DIR=`pwd`/build
    EXT_PATH=`pwd`/ext
    SRC_DIR=`pwd`/src
    cat << EOF > setup.sh
#!/usr/bin/env bash
#Setup script for "$exp" with requested version and qualifiers (may default to current version)
source ups/setup_for_development -d 
export STUDIO_PROJECT_BUILD_PATH="$BUILD_DIR"
export STUDIO_PROJECT_SRC_PATH="$SRC_DIR"
os_name=$(uname -s)
if [ \$os_name = "Darwin" ]; then
  DYLD_LIBRARY_PATH=$BUILD_DIR/lib:\$DYLD_LIBRARY_PATH
else
  LD_LIBRARY_PATH=$BUILD_DIR/lib:\$LD_LIBRARY_PATH
fi
EOF
    echo ""
    echo "The project directory '${name}' has been created."
    echo "Remember to source '${name}/setup.sh' in each new shell"
    echo "Use 'studio help' for more details."
    echo ""

else

#NORMAL DIRECTORY TREE
    if [ -d "$name" ]; then
        echo "The directory ${name} already exists, please remove it or specify a different name"
        exit 1
    fi

    mkdir -p "$name" || ( echo "Failed to project directory ${name}" ; exit 1)
    cd "$name"
    TOP=${PWD}
    mkdir build
    touch build/CMakeCache.txt
    mkdir ext
    mkdir src


# === may need to change where this is done ===
# === probably after the if switch for wkbk ===
    BUILD_DIR=$TOP/build
    EXT_PATH=$TOP/ext
    SRC_DIR=$TOP/src

#=========================================================================================================
#==============================================MAKING=====================================================
#===========================================SETUP SCRIPT==================================================
#=========================================================================================================

# ----------------------------------------------
# --- writing "default" variables to version ---
# --- and qual. otherwise keep as is. How do I -
# --- check for errors? UPS will complain but --
# --- can I do better? maybe check against ups -
# --- but for now this works                 ---
# ----------------------------------------------

echo "Creating the project directory '${name}'."
#no version specified but qual specified
    if [ -z "$ver" ] && [ ! -z "$qual" ]; then
        ver=$(ups list -aK+ "$exp" | grep $qual | sort | tail -1 | awk '{print $2}'| sed -e's/"//g')
        echo ""
        echo "  no version specified but qualifier specified..."
        echo "  latest version will be used..."
        echo "  setup $exp $ver -q $qual"
        echo "  added to setup.sh script"
        echo ""
    fi
#no qual specified but version specified
    if [ -z "$qual" ] && [ ! -z "$ver" ]; then
        qual=$(ups list -aK+ $exp | grep $ver | sort | tail -1 | awk '{print $4}'| sed -e's/"//g')
        echo ""
        echo "  no qualifier specified but version specified..."
        echo "  latest qualifier will be used..."
        echo "  setup $exp $ver -q $qual"
        echo "  added to setup.sh script"
        echo ""
    fi
#no version and no qual specified?
    if [ -z "$ver" ] && [ -z "$qual"]; then
        ver=$(ups list -aK+ "$exp" | sort | tail -1 | awk '{print $2}'| sed -e's/"//g')
        qual=$(ups list -aK+ $exp | sort | tail -1 | awk '{print $4}'| sed -e's/"//g')
        echo ""
        echo "  no qualifier and no version specified..."
        echo "  latest qualifier and version will be used..."
        echo "  setup $exp $ver -q $qual"
        echo "  added to setup.sh script"
        echo ""
    fi
    echo ""
    echo "The project directory '${name}' has been created."
    echo "Remember to source '${name}/setup.sh' in each new shell"
    echo "Use 'studio help' for more details."
    echo ""

# writing the setup script

    cat << EOF > setup.sh
#!/usr/bin/env bash
#Setup script for "$exp" with requested version and qualifiers (may default to current version)
setup studio
setup $exp $ver -q $qual
export STUDIO_PROJECT_BUILD_PATH=$BUILD_DIR
export STUDIO_PROJECT_SRC_PATH=$SRC_DIR
if [ \$(uname -s) = "Darwin" ]; then
  DYLD_LIBRARY_PATH=$BUILD_DIR/lib:\$DYLD_LIBRARY_PATH
else
  LD_LIBRARY_PATH=$BUILD_DIR/lib:\$LD_LIBRARY_PATH
fi
EOF

# <<<<<<<<<<<<<<< ending the check for artworkbook
fi
# >>>>>>>>>>>>>>> ending the check for artworkbook

#=========================================================================================================
#==============================================CMAKE======================================================
#=============================================LISTS &=====================================================
#=============================================COMMANDS====================================================
#=========================================================================================================

#CMake stuff
cat $STUDIO_INC/helpers.cmake > helpers.cmake

#cmake macro

cat $STUDIO_INC/CMakeLists.txt.tmpl > CMakeLists.txt

cat << 'EOF' > src/CMakeLists.txt
#source cmake list file
#there are two general options:
#    1. everything lives in src directory and we do it all here
#    2. subdirs (requires user to create some of the structure)
#pro-con is easyness vs. choice of what to build

#here is a basic example for option 1.
#    Plugin_name
#    add_library(<fill in which library>)
#    target_link_library(<more nonsense>)
EOF
