#!/usr/bin/env bash

# Usage: studio project [-e,-s] <product> [-v] <version> [-q <qualifiers>] [-n <dirname> ]
# Summary: Creates a project area for software suite <product>.

# Help: This will create a directory, by default named 'project',
# in the current directory, and in it a small directory tree for your
# work. See 'DIRECTORY STRUCTURE' for complete details on the
# directory structure that is generated.
#
# The project command requires use of a UPS installed product to
# provide the headers your code will include, the libraries to which
# your new code will be linked, and the art framework modules and
# servicesyour FHiCL configuration files will use. Typically this will
# be the code distribution from an experiment, but it could be any UPS
# product.
#
# If no version is specified, the project command will attempt to
# identify and use the most recent version of the named
# product. Specifying a qualifier without explicitly specifying a
# version is unreliable and should be avoided.
#
# If no qualifier is specified, the project command will attempt to use
# whatever qualifiers are found for the selected version of the
# product. If multiple qualifiers are available for that version,
# project command attempts a reasonable choice. In this condition, 
# it is best to specify qualifiers on the command line.
#
# If -n <dirname> is specified, the project directory will be given
# the specified name, rather than the default 'project'.
#
# DIRECTORY STRUCTURE
# The generated directory structure is:
#
# ├── build
# │   └── CMakeCache.txt
# ├── CMakeLists.txt
# ├── ext
# ├── helpers.cmake
# ├── setup.sh
# └── src
#     └── CMakeLists.txt
#
# The 'build' directory is where compiler and linker output will be
# put. The CMakeCache.txt file in this directory is generated and
# updated by CMake, and should not be edited.
#
# The (top-level) CMakeLists.txt contains a great deal of boilerplate
# needed by the CMake build system. It should not require any
# modification. Only edit it if you are a CMake expert, and even in
# that case be careful that your changes are only additions.
#
# The 'ext' directory is a place for you to build any external
# libraries your code will need. If you want to try linking to some
# utility that is built with a standard 'configure/make' system, use
# the --prefix option in configure to point the installation to this
# directory.
#
# The 'helpers.cmake' file contains some CMake macros used by the
# system. If you are a CMake expert, you could add your own macros
# here. Removing or altering the existing macros is likely to break
# the build system.
#
# The 'src' directory is where the source code you write will go. Code
# generated by the module skeleton generators will go here
# automatically.
#
# 'setup.sh' is a bash script must be 'sourced' in each new shell
# session in which you want to work on your project.
# 
# EXAMPLES
#    studio project lariatsoft v06_03_00 -q e10:prof
#    studio project lariatsoft v06_03_00 -q e10:prof -n lariatsoft_project
#    studio project dunetpc v06_18_01
#    studio project dunetpc v06_18_01 -n duntpc_project
#    studio project uboonecode
#    studio project uboonecode -n uboone_project
#
set -e
#=========================================READING IN ARGUMENTS============================================


arrange_opts() {
    local flags args optstr=$1
    shift

    while (($#)); do
        case $1 in
            --) args+=("$@")
                break;
                ;;
            -*) flags+=("$1")
                if [[ $optstr == *"${1: -1}:"* ]]; then
                    flags+=("$2")
                    shift
                fi
                ;;
            * ) args+=("$1")
                ;;
        esac
        shift
    done
    OPTARR=("${flags[@]}" "${args[@]}")
}

#default values
name=project
unset exp
unset qual
unset rep

#assigning arguments
OPTIND=
OPTARR=
optstring=s:v:q:r:n:

arrange_opts "$optstring" "$@"
set -- "${OPTARR[@]}"

OPTIND=1
while getopts $optstring opt;do
    case ${opt} in 
           s|e) 
                exp="$OPTARG"
                ;;
           v) 
                ver="$OPTARG"
                ;;
           q) 
                qual="$OPTARG"
                ;;
           r)
                rep="$OPTARG"
                ;;
           n)
                name="$OPTARG"
                ;;
     esac 
done

shift $((OPTIND-1))

#checking for empty call ans positional arguments
if [ $# == 0 ] ; then
    echo "'studio project' requires specification of a software suite."
    echo "Please try 'studio help project'"
    exit 2
else
    exp=$1;
    shift;
    if [ $# != 0 ] ; then 
        ver=$1
        shift
        echo $@
    fi
fi


# dummy catchers
if [ -z "$exp" ] && [ -z "$rep" ]; then
    echo "Please specify a software suite name."
    exit
fi

if [ ! -z "$exp" ] && [ ! -z "$rep" ]; then
    echo "You cannot specify a software suite name *and* a repository."
    exit
fi


#=========================================================================================================
#==============================================MAKING=====================================================
#=============================================NEC DIRS====================================================
#===========================================&cmakelists?==================================================
#====================================================================+====================================


#big if check for art workbook

#art workbook garbage
if [ "$rep" == "art-workbook" ]; then
    git clone http://cdcvs.fnal.gov/projects/art-workbook
    mv $PWD/art-workbook $PWD/$name
    mv $PWD/$name/art-workbook $PWD/$name/src
    cd $name
    mkdir build
    touch build/CMakeCache.txt
    mkdir ext
    BUILD_DIR=`pwd`/build
    EXT_PATH=`pwd`/ext
    SRC_DIR=`pwd`/src
    cat << EOF > setup.sh
#!/usr/bin/env bash
#Setup script for "$exp" with requested version and qualifiers (may default to current version)
source ups/setup_for_development -d 
export STUDIO_PROJECT_BUILD_PATH="$BUILD_DIR"
export STUDIO_PROJECT_SRC_PATH="$SRC_DIR"
os_name=$(uname -s)
if [ \$os_name = "Darwin" ]; then
  DYLD_LIBRARY_PATH=$BUILD_DIR/lib:\$DYLD_LIBRARY_PATH
else
  LD_LIBRARY_PATH=$BUILD_DIR/lib:\$LD_LIBRARY_PATH
fi
EOF
    echo ""
    echo "The project directory '${name}' has been created."
    echo "Remember to source '${name}/setup.sh' in each new shell"
    echo "Use 'studio help' for more details."
    echo ""

else

#NORMAL DIRECTORY TREE
    if [ -d "$name" ]; then
        echo "The directory ${name} already exists, please remove it or specify a different name"
        exit 1
    fi

    mkdir -p "$name" || ( echo "Failed to project directory ${name}" ; exit 1)
    cd "$name"
    TOP=${PWD}
    mkdir build
    touch build/CMakeCache.txt
    mkdir ext
    mkdir src


# === may need to change where this is done ===
# === probably after the if switch for wkbk ===
    BUILD_DIR=$TOP/build
    EXT_PATH=$TOP/ext
    SRC_DIR=$TOP/src

#=========================================================================================================
#==============================================MAKING=====================================================
#===========================================SETUP SCRIPT==================================================
#=========================================================================================================

# ----------------------------------------------
# --- writing "default" variables to version ---
# --- and qual. otherwise keep as is. How do I -
# --- check for errors? UPS will complain but --
# --- can I do better? maybe check against ups -
# --- but for now this works                 ---
# ----------------------------------------------

echo "Creating the project directory '${name}'."
#no version specified but qual specified
    if [ -z "$ver" ] && [ ! -z "$qual" ]; then
        ver=$(ups list -aK+ "$exp" | grep $qual | sort | tail -1 | awk '{print $2}'| sed -e's/"//g')
        echo ""
        echo "  no version specified but qualifier specified..."
        echo "  latest version will be used..."
        echo "  setup $exp $ver -q $qual"
        echo "  added to setup.sh script"
        echo ""
    fi
#no qual specified but version specified
    if [ -z "$qual" ] && [ ! -z "$ver" ]; then
        qual=$(ups list -aK+ $exp | grep $ver | sort | tail -1 | awk '{print $4}'| sed -e's/"//g')
        echo ""
        echo "  no qualifier specified but version specified..."
        echo "  latest qualifier will be used..."
        echo "  setup $exp $ver -q $qual"
        echo "  added to setup.sh script"
        echo ""
    fi
#no version and no qual specified?
    if [ -z "$ver" ] && [ -z "$qual"]; then
        ver=$(ups list -aK+ "$exp" | sort | tail -1 | awk '{print $2}'| sed -e's/"//g')
        qual=$(ups list -aK+ $exp | sort | tail -1 | awk '{print $4}'| sed -e's/"//g')
        echo ""
        echo "  no qualifier and no version specified..."
        echo "  latest qualifier and version will be used..."
        echo "  setup $exp $ver -q $qual"
        echo "  added to setup.sh script"
        echo ""
    fi
    echo ""
    echo "The project directory '${name}' has been created."
    echo "Remember to source '${name}/setup.sh' in each new shell"
    echo "Use 'studio help' for more details."
    echo ""

# writing the setup script

    cat << EOF > setup.sh
#!/usr/bin/env bash
#Setup script for "$exp" with requested version and qualifiers (may default to current version)
setup studio
setup $exp $ver -q $qual
export STUDIO_PROJECT_BUILD_PATH=$BUILD_DIR
export STUDIO_PROJECT_SRC_PATH=$SRC_DIR
if [ \$(uname -s) = "Darwin" ]; then
  DYLD_LIBRARY_PATH=$BUILD_DIR/lib:\$DYLD_LIBRARY_PATH
else
  LD_LIBRARY_PATH=$BUILD_DIR/lib:\$LD_LIBRARY_PATH
fi
EOF

# <<<<<<<<<<<<<<< ending the check for artworkbook
fi
# >>>>>>>>>>>>>>> ending the check for artworkbook

#=========================================================================================================
#==============================================CMAKE======================================================
#=============================================LISTS &=====================================================
#=============================================COMMANDS====================================================
#=========================================================================================================

#CMake stuff
cat << 'EOF' > helpers.cmake
#cmake macro

#macro for grabbing compiler directories
macro(get_comp_paths)
execute_process(COMMAND type -p g++ OUTPUT_VARIABLE gpp_path)
execute_process(COMMAND type -p gcc OUTPUT_VARIABLE gcc_path)
message(STATUS "gpp path: ${gpp_path}")
message(STATUS "gcc path: ${gcc_path}")
endmacro(get_comp_paths)


#some jank map macro
macro(insert_into_map _key _val)
set("map_${_key}" "${_val}")
endmacro(insert_into_map)


#here is where we find the include directories
macro(find_inc_dirs)

#getting ups product names
execute_process(COMMAND ups active COMMAND grep -v "Active ups products:" COMMAND cut -d " " -f 1 COMMAND tr '[a-z]' '[A-Z]' OUTPUT_VARIABLE dirs)
#trimming the end
string(LENGTH ${dirs} string_length)
string(SUBSTRING ${dirs} 0 ${string_length}-2 dirs_trimmed)
#making the string of dir names into a list
string(REPLACE "\n" ";" dirs_list ${dirs_trimmed})
#THIS IS THE VARIABLE WE WILL WANT TO USE IN CMakeList
set(inc_dirs_list)
#looping over product list to grab inc dirs
foreach(prod ${dirs_list})
if(prod STREQUAL "")
    continue()
    endif(prod STREQUAL "")
    list(APPEND inc_dirs_list $ENV{${prod}_INC})
    endforeach(prod)
#message(STATUS "${inc_dirs_list}")

    endmacro()

#========================

#here is where we find the lib directories
    macro(find_lib_dirs)

    execute_process(COMMAND ups active COMMAND grep -v "Active UPS products:" COMMAND cut -d " " -f 1 COMMAND tr '[a-z]' '[A-Z]' OUTPUT_VARIABLE dirs)
    string(LENGTH ${dirs} string_length)
    string(SUBSTRING ${dirs} 0 ${string_length}-2 dirs_trimmed)
    string(REPLACE "\n" ";" dirs_list ${dirs_trimmed})

    set(lib_dirs_list)
    set(lib_prod_list)
    foreach(prod ${dirs_list})
#message(STATUS "test ${prod}")
#message(STATUS "var $ENV{${prod}_LIB}")
    if(prod STREQUAL "")
        continue()
        endif(prod STREQUAL "")
        if(IS_DIRECTORY $ENV{${prod}_LIB})
#message(STATUS "$ENV{${prod}_LIB}")
            list(APPEND lib_prod_list ${prod})
            list(APPEND lib_dirs_list $ENV{${prod}_LIB})
            insert_into_map(${prod} $ENV{${prod}_LIB})
            endif(IS_DIRECTORY $ENV{${prod}_LIB})
            endforeach(prod)
#message(STATUS "${lib_dirs_list}")

            endmacro()
EOF

cat << 'EOF' > CMakeLists.txt
#CMakeLists for "$exp" with specific directory tree
include(helpers.cmake)
cmake_minimum_required(VERSION 2.8.9)
project(studio_generated)
set(CMAKE_CXX_FLAGS "-std=c++14")

if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
  set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-undefined,error")
else()
  set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,--no-undefined")
endif()

#message(STATUS "build path: $ENV{STUDIO_PROJECT_BUILD_PATH}")
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "$ENV{STUDIO_PROJECT_BUILD_PATH}/lib")

#reading in cmake cache variables from build script
set(in_src ${IS_IN_SRC})
set(work_dir ${WORKING_DIR})
set(build_dir_list ${BUILD_DIRS})

#include directories
find_inc_dirs()
foreach(inc_dir ${inc_dirs_list})
include_directories(${inc_dir})
endforeach(inc_dir ${inc_dirs_list})

#using these jank maps to link libs
find_lib_dirs()
foreach(lib_prod ${lib_prod_list})
    #message(STATUS "new product")
    #message(STATUS "${lib_prod}")
    #message(STATUS "${map_${lib_prod}}")
file(GLOB so_list ${map_${lib_prod}}/*.so ${map_${lib_prod}}/*.dylib)
    #message(STATUS "${so_list}")
foreach(so ${so_list})
        #message(STATUS "${so}")
string(REGEX REPLACE "^.*/lib([^/]*)\\.(so|dylib)$" "\\1" var ${so})
        #message(STATUS ${var})
set(${var} ${so})
endforeach(so ${so_list})
endforeach(lib_prod ${lib_prod_list})
    #root special case!
    #message(STATUS "$ENV{ROOTSYS}")
file(GLOB root_lib_list $ENV{ROOTSYS}/lib/*.so $ENV{ROOTSYS}/lib/*.dylib)
foreach(root_so ${root_lib_list})
        #message(STATUS "${root_so}")
string(REGEX REPLACE "^/.*lib(.*)\\.(so|dylib)$" "\\1" root_var ${root_so})
        #message(STATUS ${root_var})
set(${root_var} ${root_so})
endforeach(root_so ${root_lib_list})

#lib lists per plugin
set(service_lib_list)
set(module_lib_list)
set(source_lib_list)

list(INSERT service_lib_list 0
    ${art_Framework_Services_Registry}
    ${art_Persistency_Common}
    ${art_Utilities}
    ${canvas_Persistency_Common}
    ${canvas_Utilities}
    ${fhiclcpp}
    ${cetlib}
    ${boost_filesystem}
    ${boost_system}
)
list(INSERT module_lib_list 0
    ${art_Framework_Core}
    ${art_Framework_Principal}
    ${art_Persistency_Common}
    ${art_Persistency_Provenance}
    ${art_Utilities}
    ${canvas_Persistency_Common}
    ${canvas_Persistency_Provenance}
    ${canvas_Utilities}
    ${fhiclcpp}
    ${cetlib}
    ${Core}
    ${boost_filesystem}
    ${boost_system}
)
list(INSERT source_lib_list 0
    ${art_Framework_IO_Sources}
    ${Boost_FILESYSTEM_LIBRARY}
    ${Boost_SYSTEM_LIBRARY}
    ${art_Framework_Core}
    ${art_Framework_Principal}
    ${art_Persistency_Common}
    ${art_Persistency_Provenance}
    ${art_Utilities}
    ${canvas_Persistency_Common}
    ${canvas_Persistency_Provenance}
    ${canvas_Utilities}
    ${fhiclcpp}
      ${cetlib}
      ${Core}
      ${boost_filesystem}
      ${boost_system}
      )


#adding sources

#if passed an arg
if( NOT build_dir_list STREQUAL "no args")
    message(STATUS "specified dirs are: ${build_dir_list}")
    #add each build dir
    foreach(build_dir ${build_dir_list})
        #add_subdirectory(src/${build_dir})
        add_subdirectory($ENV{STUDIO_PROJECT_SRC_PATH]/${build_dir})
    endforeach(build_dir ${build_dir_list})
#if no args passed
elseif( build_dir_list STREQUAL "no args")
message(STATUS "no specified dirs...")
    #if outside srcs
    if(NOT in_src)
        message(STATUS "not in src dir... building everything...")
        add_subdirectory($ENV{STUDIO_PROJECT_SRC_PATH})
        #if in sources
    elseif(in_src)
        message(STATUS "somewhere in src... building current dir...")
        add_subdirectory(${work_dir})
    endif(NOT in_src)
endif( NOT build_dir_list STREQUAL "no args")
EOF

      cat << 'EOF' > src/CMakeLists.txt
#source cmake list file
#there are two general options:
#    1. everything lives in src directory and we do it all here
#    2. subdirs (requires user to create some of the structure)
#pro-con is easyness vs. choice of what to build

#here is a basic example for option 1.
#    Plugin_name
#    add_library(<fill in which library>)
#    target_link_library(<more nonsense>)
EOF
